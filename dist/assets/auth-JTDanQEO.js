import{r as z,g as F,R as J}from"./vendor-CPt1K6Li.js";import{a as b}from"./index-Cf1eI5hH.js";const M={BASE_URL:"/",DEV:!1,MODE:"production",PROD:!0,SSR:!1},D=e=>{let t;const n=new Set,o=(m,p)=>{const S=typeof m=="function"?m(t):m;if(!Object.is(S,t)){const l=t;t=p??(typeof S!="object"||S===null)?S:Object.assign({},t,S),n.forEach(v=>v(t,l))}},a=()=>t,g={setState:o,getState:a,getInitialState:()=>c,subscribe:m=>(n.add(m),()=>n.delete(m)),destroy:()=>{(M?"production":void 0)!=="production"&&console.warn("[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."),n.clear()}},c=t=e(o,a,g);return g},N=e=>e?D(e):D;var j={exports:{}},x={},U={exports:{}},T={};/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var E=z;function B(e,t){return e===t&&(e!==0||1/e===1/t)||e!==e&&t!==t}var W=typeof Object.is=="function"?Object.is:B,G=E.useState,K=E.useEffect,Q=E.useLayoutEffect,V=E.useDebugValue;function X(e,t){var n=t(),o=G({inst:{value:n,getSnapshot:t}}),a=o[0].inst,r=o[1];return Q(function(){a.value=n,a.getSnapshot=t,R(a)&&r({inst:a})},[e,n,t]),K(function(){return R(a)&&r({inst:a}),e(function(){R(a)&&r({inst:a})})},[e]),V(n),n}function R(e){var t=e.getSnapshot;e=e.value;try{var n=t();return!W(e,n)}catch{return!0}}function Y(e,t){return t()}var Z=typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"?Y:X;T.useSyncExternalStore=E.useSyncExternalStore!==void 0?E.useSyncExternalStore:Z;U.exports=T;var q=U.exports;/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var _=z,ee=q;function te(e,t){return e===t&&(e!==0||1/e===1/t)||e!==e&&t!==t}var re=typeof Object.is=="function"?Object.is:te,ne=ee.useSyncExternalStore,oe=_.useRef,ae=_.useEffect,se=_.useMemo,ie=_.useDebugValue;x.useSyncExternalStoreWithSelector=function(e,t,n,o,a){var r=oe(null);if(r.current===null){var d={hasValue:!1,value:null};r.current=d}else d=r.current;r=se(function(){function g(l){if(!c){if(c=!0,m=l,l=o(l),a!==void 0&&d.hasValue){var v=d.value;if(a(v,l))return p=v}return p=l}if(v=p,re(m,l))return v;var u=o(l);return a!==void 0&&a(v,u)?(m=l,v):(m=l,p=u)}var c=!1,m,p,S=n===void 0?null:n;return[function(){return g(t())},S===null?void 0:function(){return g(S())}]},[t,n,o,a]);var f=ne(e,r[0],r[1]);return ae(function(){d.hasValue=!0,d.value=f},[f]),ie(f),f};j.exports=x;var ue=j.exports;const ce=F(ue),C={BASE_URL:"/",DEV:!1,MODE:"production",PROD:!0,SSR:!1},{useDebugValue:le}=J,{useSyncExternalStoreWithSelector:de}=ce;let k=!1;const fe=e=>e;function me(e,t=fe,n){(C?"production":void 0)!=="production"&&n&&!k&&(console.warn("[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"),k=!0);const o=de(e.subscribe,e.getState,e.getServerState||e.getInitialState,t,n);return le(o),o}const ve=e=>{(C?"production":void 0)!=="production"&&typeof e!="function"&&console.warn("[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`.");const t=typeof e=="function"?N(e):e,n=(o,a)=>me(t,o,a);return Object.assign(n,t),n},he=e=>ve,ge={BASE_URL:"/",DEV:!1,MODE:"production",PROD:!0,SSR:!1};function H(e,t){let n;try{n=e()}catch{return}return{getItem:a=>{var r;const d=g=>g===null?null:JSON.parse(g,void 0),f=(r=n.getItem(a))!=null?r:null;return f instanceof Promise?f.then(d):d(f)},setItem:(a,r)=>n.setItem(a,JSON.stringify(r,void 0)),removeItem:a=>n.removeItem(a)}}const w=e=>t=>{try{const n=e(t);return n instanceof Promise?n:{then(o){return w(o)(n)},catch(o){return this}}}catch(n){return{then(o){return this},catch(o){return w(o)(n)}}}},Se=(e,t)=>(n,o,a)=>{let r={getStorage:()=>localStorage,serialize:JSON.stringify,deserialize:JSON.parse,partialize:i=>i,version:0,merge:(i,h)=>({...h,...i}),...t},d=!1;const f=new Set,g=new Set;let c;try{c=r.getStorage()}catch{}if(!c)return e((...i)=>{console.warn(`[zustand persist middleware] Unable to update item '${r.name}', the given storage is currently unavailable.`),n(...i)},o,a);const m=w(r.serialize),p=()=>{const i=r.partialize({...o()});let h;const s=m({state:i,version:r.version}).then(y=>c.setItem(r.name,y)).catch(y=>{h=y});if(h)throw h;return s},S=a.setState;a.setState=(i,h)=>{S(i,h),p()};const l=e((...i)=>{n(...i),p()},o,a);let v;const u=()=>{var i;if(!c)return;d=!1,f.forEach(s=>s(o()));const h=((i=r.onRehydrateStorage)==null?void 0:i.call(r,o()))||void 0;return w(c.getItem.bind(c))(r.name).then(s=>{if(s)return r.deserialize(s)}).then(s=>{if(s)if(typeof s.version=="number"&&s.version!==r.version){if(r.migrate)return r.migrate(s.state,s.version);console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return s.state}).then(s=>{var y;return v=r.merge(s,(y=o())!=null?y:l),n(v,!0),p()}).then(()=>{h==null||h(v,void 0),d=!0,g.forEach(s=>s(v))}).catch(s=>{h==null||h(void 0,s)})};return a.persist={setOptions:i=>{r={...r,...i},i.getStorage&&(c=i.getStorage())},clearStorage:()=>{c==null||c.removeItem(r.name)},getOptions:()=>r,rehydrate:()=>u(),hasHydrated:()=>d,onHydrate:i=>(f.add(i),()=>{f.delete(i)}),onFinishHydration:i=>(g.add(i),()=>{g.delete(i)})},u(),v||l},pe=(e,t)=>(n,o,a)=>{let r={storage:H(()=>localStorage),partialize:u=>u,version:0,merge:(u,i)=>({...i,...u}),...t},d=!1;const f=new Set,g=new Set;let c=r.storage;if(!c)return e((...u)=>{console.warn(`[zustand persist middleware] Unable to update item '${r.name}', the given storage is currently unavailable.`),n(...u)},o,a);const m=()=>{const u=r.partialize({...o()});return c.setItem(r.name,{state:u,version:r.version})},p=a.setState;a.setState=(u,i)=>{p(u,i),m()};const S=e((...u)=>{n(...u),m()},o,a);a.getInitialState=()=>S;let l;const v=()=>{var u,i;if(!c)return;d=!1,f.forEach(s=>{var y;return s((y=o())!=null?y:S)});const h=((i=r.onRehydrateStorage)==null?void 0:i.call(r,(u=o())!=null?u:S))||void 0;return w(c.getItem.bind(c))(r.name).then(s=>{if(s)if(typeof s.version=="number"&&s.version!==r.version){if(r.migrate)return[!0,r.migrate(s.state,s.version)];console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return[!1,s.state];return[!1,void 0]}).then(s=>{var y;const[L,P]=s;if(l=r.merge(P,(y=o())!=null?y:S),n(l,!0),L)return m()}).then(()=>{h==null||h(l,void 0),l=o(),d=!0,g.forEach(s=>s(l))}).catch(s=>{h==null||h(void 0,s)})};return a.persist={setOptions:u=>{r={...r,...u},u.storage&&(c=u.storage)},clearStorage:()=>{c==null||c.removeItem(r.name)},getOptions:()=>r,rehydrate:()=>v(),hasHydrated:()=>d,onHydrate:u=>(f.add(u),()=>{f.delete(u)}),onFinishHydration:u=>(g.add(u),()=>{g.delete(u)})},r.skipHydration||v(),l||S},ye=(e,t)=>"getStorage"in t||"serialize"in t||"deserialize"in t?((ge?"production":void 0)!=="production"&&console.warn("[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead."),Se(e,t)):pe(e,t),Ee=ye;class I extends Error{}I.prototype.name="InvalidTokenError";function be(e){return decodeURIComponent(atob(e).replace(/(.)/g,(t,n)=>{let o=n.charCodeAt(0).toString(16).toUpperCase();return o.length<2&&(o="0"+o),"%"+o}))}function Ie(e){let t=e.replace(/-/g,"+").replace(/_/g,"/");switch(t.length%4){case 0:break;case 2:t+="==";break;case 3:t+="=";break;default:throw new Error("base64 string is not of the correct length")}try{return be(t)}catch{return atob(t)}}function we(e,t){if(typeof e!="string")throw new I("Invalid token specified: must be a string");t||(t={});const n=t.header===!0?0:1,o=e.split(".")[n];if(typeof o!="string")throw new I(`Invalid token specified: missing part #${n+1}`);let a;try{a=Ie(o)}catch(r){throw new I(`Invalid token specified: invalid base64 for part #${n+1} (${r.message})`)}try{return JSON.parse(a)}catch(r){throw new I(`Invalid token specified: invalid json for part #${n+1} (${r.message})`)}}const $=JSON.parse(localStorage.getItem("auth-storage")||"{}");var O;(O=$.state)!=null&&O.token&&(b.defaults.headers.common.Authorization=`Bearer ${$.state.token}`);const A=e=>{try{const t=we(e),n=Date.now()/1e3;return t.exp<n}catch{return!0}},De=he()(Ee((e,t)=>({token:null,user:null,isAuthenticated:!1,login:async(n,o)=>{try{const a=await b.post("/api/auth/login",{username:n,password:o}),{token:r,user:d}=a.data;b.defaults.headers.common.Authorization=`Bearer ${r}`,e({token:r,user:d,isAuthenticated:!0})}catch(a){throw console.error("Login error:",a),a}},logout:()=>{delete b.defaults.headers.common.Authorization,localStorage.removeItem("token"),localStorage.removeItem("user"),localStorage.removeItem("rememberMe"),e({token:null,user:null,isAuthenticated:!1})},checkAuth:()=>{const{token:n}=t();if(!n){const o=localStorage.getItem("token"),a=localStorage.getItem("user");if(o&&a)if(A(o))localStorage.removeItem("token"),localStorage.removeItem("user"),localStorage.removeItem("rememberMe");else return b.defaults.headers.common.Authorization=`Bearer ${o}`,e({token:o,user:JSON.parse(a),isAuthenticated:!0}),!0;return!1}return A(n)?(e({token:null,user:null,isAuthenticated:!1}),!1):!0}}),{name:"auth-storage",storage:H(()=>localStorage)}));export{De as u};
